partall â† { # all nontrivial partitions
  Step â† {ğ•©âŠ¸âˆ¾Â¨â†•2+âŒˆÂ´Â¯1âˆ¾ğ•©}
  all â† (1âŠ¸â†“)Â¨ (âˆ¾StepÂ¨)âŸâŠ£âŸœâŸ¨âŸ¨âŸ©âŸ©Â¨ â†•7
  {(âŠ”âŸœğ•©)Â¨(â‰ ğ•©)âŠ‘all}
}
Part2 â† { # all ordered two-partitions with nonempty first
  âŸ¨âŸ©:âŸ¨âŸ©; âŸ¨aâŸ©:<âŸ¨aâŸ©â€¿"";
  (âˆ¾âŸœâŸ¨""âŸ©)âŒ¾âŠ‘(âŠ”âŸœğ•©)Â¨Â¯1â†“â¥Šâˆ¾âŒœÂ´/âŸœâŸ¨0â€¿1âŸ©â‰ ğ•©
}

I â† {ğ•¨ğ•Š"":"";(âŠ‘ğ•©)âˆ¾âˆ¾âˆ¾âŸœ(âŠ‘ğ•¨)Â¨1âŠ¸â†“ğ•©} # intersperse positive
J â† {ğ•¨ğ•Š"":"";ğ•¨(âŠ‘âŠ¸Iâˆ¾1âŠ¸âŠ‘Ëœ)ğ•©}      # intersperse negative
  ! ("+-" I "abc") â‰¡ "ab+c+"
  ! ("+-" J "abc") â‰¡ "ab+c+-"
K â† IâŸœâŠ‘ âˆ¾ {ğ•¨ J 1âŠ‘ğ•©âˆ¾âŸ¨âŸ¨âŸ©âŸ©} # resolve both
  ! ("+-" K âŸ¨âŸ¨"ab*","c"âŸ©,âŸ¨"d", "ef/"âŸ©âŸ©) â‰¡ "ab*c+def/+-"


# Cartesian product of list of tuples
Prods â† {âŸ¨âŸ©:âŸ¨âŸ©; âŸ¨aâŸ©:a; â¥Š <âŠ¸âˆ¾âŒœÂ´ (<Â¨âŒ¾(Â¯1âŠ¸âŠ‘)) ğ•©}

All â† {
  ğ•¨ğ•ŠâŸ¨âŸ©:  !"cannot arrange nothing";
  ğ•¨ğ•ŠâŸ¨aâŸ©: âŸ¨âŸ¨aâŸ©âŸ©;
  r â† (âŒ½ğ•¨)âŠ¸AllÂ¨Â¨ Partall ğ•©
  âˆ¾ (0âŠ‘ğ•¨)âŠ¸KÂ¨âˆ˜Part2Â¨ âˆ¾ProdsÂ¨ r
}

# â€¢OutÂ¨ âŸ¨"a","b","c","d","e","f"âŸ© # ones
# â€¢OutÂ¨ âˆ¾âŸ¨"+-","*/"âŸ©âŠ¸AllÂ¨ ({(1<+Â´Â¨)âŠ¸/ â¥Šâˆ¾âŒœÂ´/âŸœâŸ¨0â€¿1âŸ©â‰ ğ•©}/Â¨<) "abcdef"
# â€¢OutÂ¨ âˆ¾âŸ¨"*/","+-"âŸ©âŠ¸AllÂ¨ ({(1<+Â´Â¨)âŠ¸/ â¥Šâˆ¾âŒœÂ´/âŸœâŸ¨0â€¿1âŸ©â‰ ğ•©}/Â¨<) "abcdef"



ToInst â† {
  Step â† {in ğ•Š âŸ¨stack, inst, topâŸ©: {
    âŠ‘inâˆŠ"abcdef"? âŸ¨(1+in-'a')âˆ¾stack, inst, topâŸ©;
    âŸ¨rhs,lhsâŸ© â† 2â†‘stack
    âŸ¨topâˆ¾2â†“stack, instâˆ¾âŸ¨âŸ¨lhs,rhs,inâŸ©âŸ©, top+1âŸ©
  }}
  âŸ¨âŸ¨resâŸ©, inst, topâŸ© â† StepÂ´ âŒ½âŸ¨âŸ¨âŸ¨âŸ©,âŸ¨âŸ©,7âŸ©âŸ© âˆ¾ ğ•©
  nop â† âŸ¨0, res, '+'âŸ©
  inst âˆ¾ (5-â‰ inst)/âŸ¨nopâŸ©
}

ToC â† { âŸ¨lhs, rhs, opâŸ©:
  op â†© âŸ¨"Add","Sub","Mul","Div"âŸ©âŠ‘ËœâŠ‘"+-*/"âŠop
  "{ .lhs="âˆ¾(â€¢Fmt lhs)âˆ¾", .rhs="âˆ¾(â€¢Fmt rhs)âˆ¾", .op="âˆ¾opâˆ¾"},
"
}



ones â† âŸ¨"a","b","c","d","e","f"âŸ©
adds â† âˆ¾âŸ¨"+-","*/"âŸ©âŠ¸AllÂ¨ ({(1<+Â´Â¨)âŠ¸/ â¥Šâˆ¾âŒœÂ´/âŸœâŸ¨0â€¿1âŸ©â‰ ğ•©}/Â¨<) "abcdef"
muls â† âˆ¾âŸ¨"*/","+-"âŸ©âŠ¸AllÂ¨ ({(1<+Â´Â¨)âŠ¸/ â¥Šâˆ¾âŒœÂ´/âŸœâŸ¨0â€¿1âŸ©â‰ ğ•©}/Â¨<) "abcdef"
count â† (â‰ ones) + (â‰ adds) + (â‰ muls)

â€¢Out "
#include ""compute.h""

int computations_count = "âˆ¾(â€¢Fmt count)âˆ¾";
struct Instruction computations[] = {
"
  {â€¢Outâˆ¾Â´ToCÂ¨ToInstğ•©}Â¨ ones
  {â€¢Outâˆ¾Â´ToCÂ¨ToInstğ•©}Â¨ adds
  {â€¢Outâˆ¾Â´ToCÂ¨ToInstğ•©}Â¨ muls
â€¢Out "};"